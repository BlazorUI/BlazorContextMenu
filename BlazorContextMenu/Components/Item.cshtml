@using Microsoft.JSInterop
@inherits MenuTreeComponent
@inject BlazorContextMenuSettings settings
@inject MenuTreeTraverser menuTreeTraverser
@inject BlazorContextMenuHandler contextMenuHandler

<li id="@Id"
    onclick="@((e) => OnClickInternal(e))"
    class="@("blazor-context-menu__item " + ClassCalc)"
    style="@(Visible ? "display:block;" : "display:none;")"
    itemEnabled="@Enabled.ToString().ToLower()"
    onmouseover="@(Enabled ? $"blazorContextMenu.OnMenuItemMouseOver(event, {SubmenuXOffset ?? settings.GetTemplate(Template).SubMenuXPositionPixelsOffset}, this);" : "")"
    onmouseout="@(Enabled ? "blazorContextMenu.OnMenuItemMouseOut(event);" : "")"
    ref="@MenuItemElement">
    <CascadingValue Value="(MenuTreeComponent)this" Name="ParentComponent">
        @ChildContent
    </CascadingValue>
</li>


@functions{

#pragma warning disable BL9993, CS4014 // Component parameter is marked public

    /// <summary>
    /// Allows you to override the default css class of the menu's li element for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultCssClass { get; protected set; }

    /// <summary>
    /// Allows you to override the default "disabled" css class of the menu's li element for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultDisabledCssClass { get; protected set; }

    /// <summary>
    /// Allows you to override the default css class of the menu's li element when it contains a <see cref="SubMenu"/> for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultCssClassWithSubMenu { get; protected set; }

    /// <summary>
    /// Additional css class for the menu's li element. Use this to extend the default css
    /// </summary>
    [Parameter]
    public string CssClass { get; protected set; }

    /// <summary>
    /// Additional css class for the menu's li element when disabled. Use this to extend the default css
    /// </summary>
    [Parameter]
    public string DisabledCssClass { get; protected set; }

    /// <summary>
    /// Additional css class for the menu's li element when it contains a <see cref="SubMenu"/>. Use this to extend the default css
    /// </summary>
    [Parameter]
    public string CssClassWithSubMenu { get; protected set; }

    /// <summary>
    /// The menu item's onclick handler. A <see cref="MenuItemClickEventArgs"/> is passed to the action.
    /// If you want to cancel the click (i.e. stop the menu from closing), then set the "IsCanceled" event args property to "true".
    /// </summary>
    [Parameter]
    protected EventCallback<MenuItemClickEventArgs> Click { get; set; }

    /// <summary>
    /// Sets the item's enabled state. Default <see cref="true" />
    /// </summary>
    [Parameter]
    public bool Enabled { get; protected set; } = true;

    /// <summary>
    /// A handler that can be used to set the item's <see cref="Enabled"/> status dynamically by setting the <see cref="MenuItemEnabledHandlerArgs.IsEnabled"/> property
    /// </summary>
    [Parameter]
    protected EventCallback<MenuItemEnabledHandlerArgs> EnabledHandler { get; set; }

    /// <summary>
    /// Sets the item's visible state. Default <see cref="true" />
    /// </summary>
    [Parameter]
    public bool Visible { get; protected set; } = true;

    /// <summary>
    /// A handler that can be used to set the item's <see cref="Visible"/> status dynamically by setting the <see cref="MenuItemVisibleHandlerArgs.IsVisible"/> property
    /// </summary>
    [Parameter]
    protected EventCallback<MenuItemVisibleHandlerArgs> VisibleHandler { get; set; }

    /// <summary>
    /// The id of the li element. This is optional
    /// </summary>
    [Parameter]
    public string Id { get; protected set; }

    /// <summary>
    /// Allows you to override the default x position offset of the submenu (i.e. the distance of the submenu from it's parent menu).
    /// </summary>
    [Parameter]
    public int? SubmenuXOffset { get; protected set; }

    [Parameter]
    protected RenderFragment ChildContent { get; set; }

    protected string ClassCalc
    {
        get
        {
            var template = settings.GetTemplate(Template);
            string classes = null;
            if (Enabled)
            {
                classes = Helpers.AppendCssClasses((OverrideDefaultCssClass ?? template.DefaultCssOverrides.MenuItemCssClass),
                                            (CssClass ?? settings.GetTemplate(Template).MenuItemCssClass));
            }
            else
            {
                classes = Helpers.AppendCssClasses((OverrideDefaultDisabledCssClass ?? template.DefaultCssOverrides.MenuItemDisabledCssClass),
                                            (DisabledCssClass ?? settings.GetTemplate(Template).MenuItemDisabledCssClass));
            }

            var hasSubMenu = menuTreeTraverser.HasSubMenu(this);
            if (hasSubMenu)
            {
                classes = Helpers.AppendCssClasses(classes,
                        (OverrideDefaultCssClassWithSubMenu ?? template.DefaultCssOverrides.MenuItemWithSubMenuCssClass),
                        (CssClassWithSubMenu ?? settings.GetTemplate(Template).MenuItemWithSubMenuCssClass));
            }

            return classes;
        }
    }

    protected ElementRef MenuItemElement { get; set; }
    protected string Template { get; set; }
    protected ContextMenu RootMenu { get; set; }
    protected ContextMenu ParentMenu { get; set; }

    protected override async Task OnInitAsync()
    {
        if (string.IsNullOrEmpty(Id))
        {
            Id = Guid.NewGuid().ToString();
        }

        RootMenu = menuTreeTraverser.GetRootContextMenu(this);
        if (RootMenu == null) throw new Exception("Item component must be a child of a ContextMenu component");
        ParentMenu = menuTreeTraverser.GetClosestContextMenu(this);
        Template = ParentMenu.GetActiveTemplate();

        var contextMenuTarget = RootMenu.GetTarget();
        if (VisibleHandler.HasDelegate)
        {
            //TODO: Remove casting when 'this' is fixed in blazor
            var visibleArgs = new MenuItemVisibleHandlerArgs(RootMenu.Id, contextMenuTarget, (Item)(object)this, Visible);
            await VisibleHandler.InvokeAsync(visibleArgs);
            Visible = visibleArgs.IsVisible;
        }

        if (EnabledHandler.HasDelegate)
        {
            //TODO: Remove casting when 'this' is fixed in blazor
            var enabledArgs = new MenuItemEnabledHandlerArgs(RootMenu.Id, contextMenuTarget, (Item)(object)this, Enabled);
            await EnabledHandler.InvokeAsync(enabledArgs);
            Enabled = enabledArgs.IsEnabled;
        }
    }

    protected async Task OnClickInternal(UIMouseEventArgs e)
    {
        if (!Enabled) return;

        var contextMenuTarget = RootMenu.GetTarget();
        //TODO: Remove casting when 'this' is fixed in blazor
        var args = new MenuItemClickEventArgs(e, RootMenu.Id, contextMenuTarget, MenuItemElement, (Item)(object)this);
        if (Click.HasDelegate)
        {
            await Click.InvokeAsync(args);
            if (!args.IsCanceled)
            {
                contextMenuHandler.HideMenu(RootMenu.Id);
            }
        }
    }
#pragma warning restore BL9993, CS4014 // Component parameter is marked public
}